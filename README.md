 <h1 align="center"> HD44780 I2C Driver</h1>

 # Driver Overview #
 This driver is targeted for STM32 boards and HD44780-based I2C display modules. Currently works on 16x2 display such as the one shown below:
 <p align="center">
 <img src="https://user-images.githubusercontent.com/79535234/150162473-e139d7c3-d8eb-4695-877e-66c1ef45de0c.png" width="300" />
 <p>

 **Main featues:**
 * Standard LCD control (write, get cursor position, set cursor position, animate text, ...). Fully explained in [Driver Summary](#driver-summary) section.
 * Busy flag check and address counter read between commands.
 * User defined error handler if HD44780 times out after a command is sent.
  
 # Hardware & Software Requirements #
 * LCD display with HD44780 driver.
 * [PCF8574-based 8-bit I/O to I2C module](https://www.amazon.com/1602LCD-Display-Serial-Interface-Arduino/dp/B01MXGXPKU/ref=asc_df_B01MXGXPKU/?tag=hyprod-20&linkCode=df0&hvadid=167146065113&hvpos=&hvnetw=g&hvrand=358405417949042193&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=9004331&hvtargid=pla-305845701989&psc=1/) that operates in four bit mode.
 * STM32-based board and 5V supply for LCD.
 * STM32CubeIDE (HAL for I2C communication).
  
 # Porting #
 1. Add HD44780.c and HD44780.h into STM32CubeIDE project.
 2. Configure I2C pins using CubeMX and HAL-generated code.
 3. `#include "HD44780.h"`
 4. Define `HD44780_NUM_ROWS`, `HD44780_NUM_COLS`, and `HW061_I2C_ADDR` in `HD44780.h`.
 4. In `main.c` create a HD44780_HandleTypeDef object and intialize display with `HD44780_Init()`.

**Initialization and Print Example**
   
`HD44780.h`
```c
#define HD44780_NUM_ROWS 		2
#define HD44780_NUM_COLS 		16
#define HW061_I2C_ADDR 			(0x27<<1) /* PCF8574 (pg. 13) */
```
   
`main.c`
```c
#include "main.h"
#include "HD44780.h"

I2C_HandleTypeDef hi2c1;              /* Automatically generated by HAL */
HD44780_HandleTypeDef HD44780_Handle; /* Create HD44780_HandleTypeDef object */
   
void SystemClock_Config(void);        /* Automatically generated by HAL */
static void MX_GPIO_Init(void);       /* Automatically generated by HAL */
static void MX_I2C1_Init(void);       /* Automatically generated by HAL */

int main(void)
{
  HAL_Init();                         /* Automatically generated by HAL */
  SystemClock_Config();               /* Automatically generated by HAL */
  MX_GPIO_Init();                     /* Automatically generated by HAL */
  MX_I2C1_Init();                     /* Automatically generated by HAL */

  if (HD44780_Init(&hi2c1, &HD44780_Handle))              /* Returns true if initialization successful */
  {
	  HD44780_Print(&HD44780_Handle, "Hello World Row1");   /* Prints text on first row */
	  HD44780_Set_Cursor_Position(&HD44780_Handle, 1, 0);   /* Moves cursor to second row */
	  HD44780_Print(&HD44780_Handle, "Hello World Row2");   /* Prints text on second row */
  }
}
```
	 
# Driver Summary #
```c
bool HD44780_Init(I2C_HandleTypeDef *I2C_Handle, HD44780_HandleTypeDef *Display_Handle)
```
<details>
<summary>DESCRIPTION</summary>
<p><br>Establishes I2C communication between the STM32 and HD44780 display. Initializes the display through a software reset and places cursor at (0,0) position.
	
### Parameters: ###
* `I2C_Handle` -- pointer to the I2C handle created by HAL
* `Display_Handle` -- pointer to HD44780_HandleTypeDef object that user creates
	 
### Returns: ###
* `true` -- if initialization successful.
	
### Example Call ###
```c
I2C_HandleTypeDef hi2c1; /* Automatically generated by HAL */
HD44780_HandleTypeDef MyDisplay; /* Create HD44780_HandleTypeDef object */
bool success = HD44780_Init(&hi2c1, &MyDisplay);
```
</p>
</details>
	 
---

<br>
<br>
	 
```c
void HD44780_Print(HD44780_HandleTypeDef *Display_Handle, const char *str)
```
<details>
<summary>DESCRIPTION</summary>
<p><br>Prints text to the LCD starting at current cursor position. Automatically goes to the next row when there's no more display room on the previous row. Stops printing and sets cursor to (0,0) if there's no more display room.
	
### Parameters: ###
* `Display_Handle` -- pointer to HD44780_HandleTypeDef object that user creates
* `str` -- string to print
	
### Example Call ###
```c
HD44780_Print(&MyDisplay, "Hello World!");
```
</p>
</details>
	 
---

<br>
<br>
	 
```c
void HD44780_Transmit_Command(HD44780_HandleTypeDef *Display_Handle, HD44780_User_Command_List UserCommand)
```
<details>
<summary>DESCRIPTION</summary>
<p><br>Sends pre-defined commands to the display.
	
### Parameters: ###
* `Display_Handle` -- pointer to HD44780_HandleTypeDef object that user creates
* `UserCommand` -- command defined in HD44780_User_Command_List enum. This command list currently includes:
	* `CLEAR_DISPLAY` -- clears contents of display and returns cursor to (0,0)
	* `RETURN_HOME` -- returns cursor to (0,0) but doesn't clear display
	* `DISPLAY_OFF` -- turns backlight off
	* `CURSOR_ON` -- turns cursor on
	* `CURSOR_OFF` -- turns cursor off
	* `CURSOR_BLINK` -- blinks the cursor
	* `CURSOR_UNBLINK` -- stops blinking the cursor
	* `DISPLAY_ON` -- turns the backlight on
	
### Example Call ###
```c
HD44780_Transmit_Command(&MyDisplay, CURSOR_ON);
```
</p>	
</details>
	 
---

<br>
<br>
	 
```c
void HD44780_Set_Cursor_Position(HD44780_HandleTypeDef *Display_Handle, uint8_t row, uint8_t column)
```
<details>
<summary>DESCRIPTION</summary>
<p><br>Sets the cursor position at the given coordinates. Only runs if the given coordinate is within the display's dimensions.
	
### Parameters: ###
* `Display_Handle` -- pointer to HD44780_HandleTypeDef object that user creates
* `row` -- 0-indexed row
* `column` -- 0-indexed column
	
### Example Call ###
```c
HD44780_Set_Cursor_Position(&MyDisplay, 0, 5); /* First row, 6th column */
```
</p>
</details>
	 
---

<br>
<br>

```c
void HD44780_Animate_Text(HD44780_HandleTypeDef *Display_Handle, uint8_t NumberOfScrolls)
```
<details>
<summary>DESCRIPTION</summary>
<p><br>Scrolls all of the display's text from left to right. Only executes if there is currently text on the display.
	
### Parameters: ###
* `Display_Handle` -- pointer to HD44780_HandleTypeDef object that user creates
* `NumberOfScrolls` -- number of full sweeps across the entire display to perform. Each sweep takes ~4 seconds on a 16x2 display. 
	
### Example Call ###
```c
HD44780_Animate_Text(&MyDisplay, 2);
```
</p>
</details>
	 
---

<br>
<br>
	 
```c
uint8_t HD44780_Get_Row_Index(HD44780_HandleTypeDef *Display_Handle)
```
<details>
<summary>DESCRIPTION</summary>
<p><br>Returns the current row index the cursor is on.
	
### Parameters: ###
* `Display_Handle` -- pointer to HD44780_HandleTypeDef object that user creates

### Returns ###
* 0-indexed row that the cursor is currently on.
	
### Example Call ###
```c
uint8_t currentrow = HD44780_Get_Row_Index(&MyDisplay);
```
</p>
</details>
	 
---

<br>
<br>
	 
```c
uint8_t HD44780_Get_Column_Index(HD44780_HandleTypeDef *Display_Handle)
```
<details>
<summary>DESCRIPTION</summary>
<p><br>Returns the current column index the cursor is on.
	
### Parameters: ###
* `Display_Handle` -- pointer to HD44780_HandleTypeDef object that user creates

### Returns ###
* 0-indexed column that the cursor is currently on
	
### Example Call ###
```c
uint8_t currentcolumn = HD44780_Get_Column_Index(&MyDisplay);
```
</p>
</details>
	 
---

<br>
<br>
 
```c
char HD44780_Read_Character(HD44780_HandleTypeDef *Display_Handle, uint8_t row, uint8_t column)
```
<details>
<summary>DESCRIPTION</summary>
<p><br>Reads the display at the given coordinate. 
	
### Parameters: ###
* `Display_Handle` -- pointer to HD44780_HandleTypeDef object that user creates
* `row` -- 0-indexed row coordinate
* `column` -- 0-indexed column coordinate

### Returns ###
* Character at the given coordinate. Returns NULL character if coordinates are out of bounds of the display.
	
### Example Call ###
```c
char val = HD44780_Read_Character(&MyDisplay, 0, 0); /* Read first element on display */
```
</p>
</details>
	 
---

<br>
<br>
	 
```c
static void HD44780_Error_Handler(HD44780_HandleTypeDef *Display_Handle)
```
<details>
<summary>DESCRIPTION</summary>
<p><br>Executes if the HD44780 is continuously busy after sending a command or data. More specifically, if the busy flag is set for more than ~100ms. Display_Handle->State will automatically be set to HD44780_TIMEOUT then this function will execute. It is up to the user on how to handle the error according to his/her application. This is a blocking function that will not exit until Display_Handle->State is set back to HD44780_READY. 
	
### Parameters: ###
* `Display_Handle` -- pointer to HD44780_HandleTypeDef object that user creates	
</p>
</details>
